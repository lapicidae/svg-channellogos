#!/bin/bash

# SVG2PNG
# To use this you need to have awk, librsvg, inkscape and imagemagick installed.



## Config ##
WIDTH=800

## Defaults ##
OVERWRITE="false"
FIXED="false"
SQUARE="false"
debug="false"

## Do not change ##
IFS=$'\n'
trap 'echo oh, I am slain; exit 130' INT



## Usage Message ##
function usage {
	echo "########## svg2png ##########" 1>&2
	if [ ! -z "${1}" ]; then
		echo "ERROR: $1" 1>&2
	fi
	echo "Usage: $0 [-i <input dir>] [-o <output dir>] [-w <width>] [-r <fixed rectangle>] [-s <fixed square>] [-u <unlink>] [-f <overwrite>] [-d <debug>]" 1>&2
	echo "#############################" 1>&2
	exit 1
}



## check Parameters ##
while getopts "di:o:w:h:rsuf" o; do
	case "${o}" in
		d)
			debug="true"
			;;
		i)
			INPUT_DIR=$(readlink -e ${OPTARG})
			;;
		o)	OUTPUT_DIR=${OPTARG}
			;;
		w)
			WIDTH=${OPTARG}
			;;
		r)
			FIXED="true"
			SQUARE="false"
			;;
		s)
			FIXED="true"
			SQUARE="true"
			;;
		u)
			UNLINK="true"
			;;
		f)
			OVERWRITE="true"
			;;
		*)
			usage
			;;
	esac
done
shift $((OPTIND-1))

if [ -z "$INPUT_DIR" ] || [ -z "$OUTPUT_DIR" ]; then
	usage "Function or Path missing!"
fi



## width & height ##
if [ -z ${HEIGHT} ] && [ $FIXED = "true" ] && [ $SQUARE = "true" ]; then
	HEIGHT=$WIDTH
	if [ $debug = "true" ]; then
		echo "Square Format (W x H): $WIDTH x $HEIGHT px"
	fi
elif [ -z ${HEIGHT} ] && [ $FIXED = "true" ] && [ $SQUARE = "false" ] ; then
	HEIGHT=$(awk -v wdth="$WIDTH" 'BEGIN {printf ("%d\n", wdth/(16/9))}')
	if [ $debug = "true" ]; then
		echo "Rectangle Format (W x H): $WIDTH x $HEIGHT px"
	fi
fi



## check DIR ##
if [ -z "$INPUT_DIR" ]; then
	usage "$INPUT_DIR is empty!"
elif [ ! -e "$OUTPUT_DIR" ]; then
	mkdir -p "$OUTPUT_DIR"
elif [ ! -d "$OUTPUT_DIR" ]; then
	usage "$OUTPUT_DIR already exists but is not a directory"
fi

OUTPUT_DIR=$(readlink -e "$OUTPUT_DIR")



## Variables ##
FORMAT=$(echo -e "$WIDTH"x"$HEIGHT")
WORKDIR=$(mktemp -d --suffix=_svg2png)
SUBDIR=$( ls -1p "$INPUT_DIR" | grep / | sed 's/\///g' )
cd "$WORKDIR"



# Copy and resize .png files
pngfile=`ls -1 "$INPUT_DIR"/*.png 2>/dev/null | wc -l`
if [ $pngfile != 0 ]; then
	mogrify -path "$OUTPUT_DIR" -auto-orient -thumbnail "$WIDTH"x "$INPUT_DIR"/*.png
fi


# Convert .svg to .png and keep links
for file in "$INPUT_DIR"/*.svg; do
	pngname="$(basename "$file" .svg).png"
	if [ ! -f "$OUTPUT_DIR/$pngname" ] || [ $OVERWRITE = "true" ]; then
		if [ $debug = "true" ]; then
			echo "Processing '$file'..."
		fi
		if [ -L "$file" ] && [ ! -e "$file" ]; then
			continue
		elif [ -L "$file" ]; then
			cd "$OUTPUT_DIR"
			destination="$(basename "$(readlink "$file")" .svg).png"
			ln -s "$destination" "$pngname"
		elif [ $FIXED = "true" ]; then
			convert -density $WIDTH -background none "$file" -resize "$FORMAT" -gravity center -extent "$FORMAT" "$OUTPUT_DIR/$pngname" || echo "^^ ERROR converting $file ^^"
		else
			rsvg-convert --keep-aspect-ratio --width=$WIDTH "$file" --output="$OUTPUT_DIR/$pngname"
		fi
		if [ $debug = "true" ]; then
			echo "DONE: '$pngname'"
		fi
	else
		if [ $debug = "true" ]; then
			echo "$pngname already exists!"
		fi
	fi
done



## Subdirs ##
for prefix in ${SUBDIR[@]}; do
	for filename in "$INPUT_DIR/$prefix"/*; do
		case $(file --mime-type -b "$filename") in
			image/png)	# Copy, rename and resize .png files
				OUTFILE=$(echo -e "$OUTPUT_DIR"/"$prefix"_"$filename")
				convert "$filename" -resize "$WIDTH" "$OUTFILE"
				if [ $debug = "true" ]; then
					echo "Converted $prefix/$filename to $prefix"_"$filename"
				fi
			;;
			image/svg*)	# Rename and Convert .svg to .png
				pngname="$(basename "$filename" .svg).png"
				OUTFILE=$(echo -e "$OUTPUT_DIR"/"$prefix"_"$pngname")
				if [ $FIXED = "true" ] ; then
					convert -density $WIDTH -background none "$filename" -resize "$FORMAT" -gravity center -extent "$FORMAT" "$OUTFILE" || echo "^^ ERROR converting $filename ^^"
				else
					rsvg-convert --keep-aspect-ratio --width=$WIDTH "$filename" --output="$OUTFILE"
				fi
				if [ $debug = "true" ]; then
					echo "Converted $prefix/$filename to $prefix"_"$pngname"
					exit 0
				fi
			;;
		esac
	done
done



## Unlink ##
if [ ${UNLINK:="false"} = "true" ]; then
	UNL_TMP_DIR=$(mktemp -d --tmpdir=$WORKDIR --suffix=_unlink)
	if [ -d "$UNL_TMP_DIR" ]; then
		mkdir -p "$UNL_TMP_DIR"
	fi

	LINKS=($(find "$OUTPUT_DIR" -type l -print))

	for unlink in ${LINKS[@]}; do
		UN_INPUT=$(readlink -e -f $unlink)
		UN_OUTPUT=$(basename $unlink)
		cp "$UN_INPUT" "$UNL_TMP_DIR/$UN_OUTPUT"
	done

	mv "$UNL_TMP_DIR"/* "$OUTPUT_DIR" 2>/dev/null | true
fi



## CleanUp ##
rm -rf $WORKDIR
